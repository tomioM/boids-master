<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Filled Metaball Merge</title>
  <style>
    body { margin: 0; background: #111; }
    canvas { display: block; margin: auto; background: #fff; }
  </style>
</head>
<body>
<canvas id="canvas" width="600" height="600"></canvas>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const circles = [
  { x: 150, y: 500, r: 200 },
  { x: 330, y: 500, r: 80 },
  { x: 600, y: 500, r: 80 },
];



const gridSize = 4;
const threshold = 1;
const width = canvas.width;
const height = canvas.height;
const cols = Math.floor(width / gridSize);
const rows = Math.floor(height / gridSize);

// Compute scalar field on grid
const fieldValues = [];
for(let y = 0; y <= rows; y++) {
  for(let x = 0; x <= cols; x++) {
    const px = x * gridSize;
    const py = y * gridSize;
    let sum = 0;
    for (const c of circles) {
      const dx = px - c.x;
      const dy = py - c.y;
      const d2 = dx*dx + dy*dy + 0.0001;
      sum += (c.r*c.r) / d2;
    }
    fieldValues[y * (cols+1) + x] = sum;
  }
}

// Marching Squares edge lookup table (pairs of edges to connect)
const edgeTable = {
  1:  [[3,0]],
  2:  [[0,1]],
  3:  [[3,1]],
  4:  [[1,2]],
  5:  [[3,0],[1,2]],
  6:  [[0,2]],
  7:  [[3,2]],
  8:  [[2,3]],
  9:  [[0,2]],
  10: [[0,1],[2,3]],
  11: [[1,2]],
  12: [[1,3]],
  13: [[0,1]],
  14: [[3,0]],
};

function lerp(a,b,t) {
  return a + (b - a)*t;
}

// Get interpolated point on edge
function interp(p1, p2, v1, v2) {
  const t = (threshold - v1)/(v2 - v1 + 0.00001);
  return {
    x: lerp(p1.x, p2.x, t),
    y: lerp(p1.y, p2.y, t),
  };
}

function getField(x,y) {
  return fieldValues[y * (cols+1) + x];
}

function getPoint(x,y) {
  return { x: x*gridSize, y: y*gridSize };
}

function marchingSquares() {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = "#000";
  ctx.beginPath();

  // We'll store edges to link them into continuous polygons
  const segments = [];

  for(let y=0; y < rows; y++) {
    for(let x=0; x < cols; x++) {
      // Corners and their scalar values
      const squareCorners = [
        {p: getPoint(x,y),     v: getField(x,y)},
        {p: getPoint(x+1,y),   v: getField(x+1,y)},
        {p: getPoint(x+1,y+1), v: getField(x+1,y+1)},
        {p: getPoint(x,y+1),   v: getField(x,y+1)},
      ];

      // Determine case index for marching squares
      let caseIndex = 0;
      if(squareCorners[0].v > threshold) caseIndex |= 1;
      if(squareCorners[1].v > threshold) caseIndex |= 2;
      if(squareCorners[2].v > threshold) caseIndex |= 4;
      if(squareCorners[3].v > threshold) caseIndex |= 8;

      if(caseIndex === 0 || caseIndex === 15) continue;

      const edges = edgeTable[caseIndex];
      if(!edges) continue;

      for(const edge of edges) {
        const a = edge[0], b = edge[1];

        // Map edge index to corner indices for interpolation
        // Edges:
        // 0 = between corner0 and corner1 (top)
        // 1 = between corner1 and corner2 (right)
        // 2 = between corner2 and corner3 (bottom)
        // 3 = between corner3 and corner0 (left)
        const edgePoints = [
          [squareCorners[0], squareCorners[1]],
          [squareCorners[1], squareCorners[2]],
          [squareCorners[2], squareCorners[3]],
          [squareCorners[3], squareCorners[0]],
        ];

        const p1 = interp(edgePoints[a][0].p, edgePoints[a][1].p, edgePoints[a][0].v, edgePoints[a][1].v);
        const p2 = interp(edgePoints[b][0].p, edgePoints[b][1].p, edgePoints[b][0].v, edgePoints[b][1].v);

        // Add segment to list
        segments.push([p1, p2]);
      }
    }
  }

  // Now link the segments into closed polygons
  // Basic approach: keep chaining segments where end matches start of another
  const polygons = [];
  while(segments.length > 0) {
    let polygon = [];
    let seg = segments.pop();
    polygon.push(seg[0], seg[1]);

    let extended = true;
    while(extended) {
      extended = false;
      for(let i=0; i<segments.length; i++) {
        const s = segments[i];
        if(pointsClose(polygon[polygon.length - 1], s[0])) {
          polygon.push(s[1]);
          segments.splice(i,1);
          extended = true;
          break;
        }
        else if(pointsClose(polygon[polygon.length - 1], s[1])) {
          polygon.push(s[0]);
          segments.splice(i,1);
          extended = true;
          break;
        }
        else if(pointsClose(polygon[0], s[1])) {
          polygon.unshift(s[0]);
          segments.splice(i,1);
          extended = true;
          break;
        }
        else if(pointsClose(polygon[0], s[0])) {
          polygon.unshift(s[1]);
          segments.splice(i,1);
          extended = true;
          break;
        }
      }
    }
    polygons.push(polygon);
  }

  // Draw polygons filled
  for(const poly of polygons) {
    if(poly.length < 3) continue;
    ctx.moveTo(poly[0].x, poly[0].y);
    for(let i=1; i<poly.length; i++) {
      ctx.lineTo(poly[i].x, poly[i].y);
    }
    ctx.closePath();
  }

  ctx.fill();
}

function pointsClose(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return dx*dx + dy*dy < 1; // tolerance squared distance
}

marchingSquares();
</script>
</body>
</html>
